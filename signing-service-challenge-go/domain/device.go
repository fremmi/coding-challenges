package domain

import (
	"encoding/base64"
	"errors"
	"fmt"
	"sync"

	"github.com/fiskaly/coding-challenges/signing-service-challenge/crypto"
	"k8s.io/klog"
)

type Transaction struct {
	Signature string
	Data      string
}

type Device struct {
	Id    string
	Label string

	Algorithm crypto.Algorithm
	KeyPair   crypto.KeyPair
	Marshaler crypto.Marshaler
	Generator crypto.Generator

	crypto.Signer

	sync.Mutex           // to protect concurrent access to the device
	Counter       int64  // used to track the number of transactions signed
	lastSignature string // the last signature generated by this device base64 encoded

	// Store device transactions
	transactions map[int64]Transaction
}

func NewDevice(id, label string, algo crypto.Algorithm) (*Device, error) {
	var d = &Device{
		Id:        id,
		Label:     label,
		Algorithm: algo,
		Counter:   0,
	}

	switch algo {
	case crypto.AlgorithmRSA:
		d.Marshaler = crypto.NewRSAMarshaler()
		d.Generator = &crypto.RsaGenerator{}
	case crypto.AlgorithmECC:
		d.Marshaler = crypto.NewECCMarshaler()
		d.Generator = &crypto.EccGenerator{}
	default:
		return nil, crypto.ErrUnsupportedAlgorithm
	}

	var err error
	if d.KeyPair, err = d.Generator.GenerateKeyPair(); err != nil {
		return nil, err
	}

	d.Signer = crypto.NewSigner(algo, d.KeyPair)

	// Initialize the last signature to  base64 device ID
	d.lastSignature = base64.StdEncoding.EncodeToString([]byte(d.Id))

	d.transactions = make(map[int64]Transaction)
	return d, nil
}

func (d *Device) SignTransaction(transaction string) (string, string, error) {
	d.Lock()
	defer d.Unlock()

	// The case where counter is 0 is handled by the device creation
	data := fmt.Sprintf("%d_%s_%s", d.Counter, transaction, d.lastSignature)
	klog.Infof("Signing transaction with data: %s", data)

	if signature, err := d.Signer.Sign([]byte(data)); err != nil {
		return "", "", err
	} else {
		d.lastSignature = base64.StdEncoding.EncodeToString(signature)
		d.transactions[d.Counter] = Transaction{
			Signature: d.lastSignature,
			Data:      data,
		}
		d.Counter++
		return d.lastSignature, data, nil
	}
}

func (d *Device) ListTransactions() []Transaction {
	d.Lock()
	defer d.Unlock()

	arr := []Transaction{}

	for _, tr := range d.transactions {
		arr = append(arr, tr)
	}

	return arr
}

func (d *Device) GetTransaction(index int64) (Transaction, error) {
	d.Lock()
	defer d.Unlock()

	if index >= int64(len(d.transactions)) {
		return Transaction{}, errors.New("Transaction does not exist")
	}

	return d.transactions[index], nil
}

package domain

import (
	"encoding/base64"
	"errors"
	"fmt"
	"sync"

	"github.com/fiskaly/coding-challenges/signing-service-challenge/crypto"
	"k8s.io/klog"
)

// Transaction represents a signed transaction with its signature and data.
type Transaction struct {
	Signature string
	Data      string
}

// Device represents a signature device that can sign transactions.
// it keeps the list of transactions signed by this device
type Device struct {
	Id    string
	Label string

	Algorithm crypto.Algorithm
	KeyPair   crypto.KeyPair
	Marshaler crypto.Marshaler
	Generator crypto.Generator

	crypto.Signer

	sync.Mutex           // to protect concurrent access to the device
	Counter       int64  // used to track the number of transactions signed
	LastSignature string // the last signature generated by this device base64 encoded

	// Store device Transactions
	// index is the counter value when the transaction happens
	Transactions map[int64]Transaction
}

func NewDevice(id, label string, algo crypto.Algorithm) (*Device, error) {
	klog.Infof("Creating new device with ID: %s, Label: %s, Algorithm: %s", id, label, algo)
	var d = &Device{
		Id:        id,
		Label:     label,
		Algorithm: algo,
		Counter:   0,
	}

	// Initialize the marshaler and generator based on the algorithm
	switch algo {
	case crypto.AlgorithmRSA:
		d.Marshaler = crypto.NewRSAMarshaler()
		d.Generator = crypto.NewRsaGenerator()
	case crypto.AlgorithmECC:
		d.Marshaler = crypto.NewECCMarshaler()
		d.Generator = crypto.NewEccGenerator()
	default:
		klog.Errorf("Unsupported algorithm: %s", algo)
		return nil, crypto.ErrUnsupportedAlgorithm
	}

	var err error
	if d.KeyPair, err = d.Generator.GenerateKeyPair(); err != nil {
		klog.Errorf("Failed to generate key pair for device %s: %v", id, err)
		return nil, err
	}

	d.Signer = crypto.NewSigner(algo, d.KeyPair)

	// Initialize the last signature to  base64 device ID
	d.LastSignature = base64.StdEncoding.EncodeToString([]byte(d.Id))

	// Initialize the transactions map
	d.Transactions = make(map[int64]Transaction)
	return d, nil
}

// SignTransaction signs a transaction with the device's private key.
// It returns the signature, the data that was signed, and any error encountered.
// Counter is incremented after each successful signing operation.
func (d *Device) SignTransaction(transaction string) (string, string, error) {
	// Lock the device to ensure thread-safe access
	d.Lock()
	defer d.Unlock()

	// The case where counter is 0 is handled by the device creation
	data := fmt.Sprintf("%d_%s_%s", d.Counter, transaction, d.LastSignature)
	klog.Infof("Signing transaction data: %s", data)

	if signature, err := d.Signer.Sign([]byte(data)); err != nil {
		klog.Errorf("Failed to sign transaction for device %s: %v", d.Id, err)
		return "", "", err
	} else {
		d.LastSignature = base64.StdEncoding.EncodeToString(signature)
		// Store the transaction with its signature
		d.Transactions[d.Counter] = Transaction{
			Signature: d.LastSignature,
			Data:      data,
		}
		// increase the counter for the next transaction
		d.Counter++
		return d.LastSignature, data, nil
	}
}

// ListTransactions returns a slice of all transactions signed by the device.
func (d *Device) ListTransactions() []Transaction {
	// TODO. Use read and write locks to optimize concurrent access
	// Here read is enough
	d.Lock()
	defer d.Unlock()

	arr := []Transaction{}

	for _, tr := range d.Transactions {
		arr = append(arr, tr)
	}

	return arr
}

// GetTransaction retrieves a specific transaction by its index.
// The index is the counter value at which the transaction was signed.
func (d *Device) GetTransaction(index int64) (Transaction, error) {
	// TODO use a read lock here
	d.Lock()
	defer d.Unlock()

	if index >= int64(len(d.Transactions)) || index < 0 {
		klog.Errorf("Transaction index %d does not exist for device %s", index, d.Id)
		return Transaction{}, errors.New("Transaction does not exist")
	}

	return d.Transactions[index], nil
}

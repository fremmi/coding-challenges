package domain

import (
	"encoding/base64"
	"fmt"
	"sync"

	"github.com/fiskaly/coding-challenges/signing-service-challenge/crypto"
	"k8s.io/klog"
)

type Device struct {
	Id    string
	Label string

	Algorithm crypto.Algorithm
	KeyPair   crypto.KeyPair
	Marshaler crypto.Marshaler
	Generator crypto.Generator

	crypto.Signer

	sync.Mutex           // to protect concurrent access to the device
	Counter       int64  // used to track the number of transactions signed
	lastSignature string // the last signature generated by this device base64 encoded
}

func NewDevice(id, label string, algo crypto.Algorithm) (*Device, error) {
	var d = &Device{
		Id:        id,
		Label:     label,
		Algorithm: algo,
		Counter:   0,
	}

	switch algo {
	case crypto.AlgorithmRSA:
		d.Marshaler = crypto.NewRSAMarshaler()
		d.Generator = &crypto.RsaGenerator{}
	case crypto.AlgorithmECC:
		d.Marshaler = crypto.NewECCMarshaler()
		d.Generator = &crypto.EccGenerator{}
	default:
		return nil, crypto.ErrUnsupportedAlgorithm
	}

	var err error
	if d.KeyPair, err = d.Generator.GenerateKeyPair(); err != nil {
		return nil, err
	}

	d.Signer = crypto.NewSigner(algo, d.KeyPair)

	// Initialize the last signature to  base64 device ID
	d.lastSignature = base64.StdEncoding.EncodeToString([]byte(d.Id))
	return d, nil
}

func (d *Device) SignTransaction(transaction string) (string, string, error) {
	d.Lock()
	defer d.Unlock()

	// The case where counter is 0 is handled by the device creation
	data := fmt.Sprintf("%d_%s_%s", d.Counter, transaction, d.lastSignature)
	klog.Infof("Signing transaction with data: %s", data)

	if signature, err := d.Signer.Sign([]byte(data)); err != nil {
		return "", "", err
	} else {
		d.Counter++
		d.lastSignature = base64.StdEncoding.EncodeToString(signature)
		return d.lastSignature, transaction, nil
	}
}
